---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051802"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Lencana Versi][2]][1]</sup>

[![Status Build][3]][4]
[![status dependensi][5]][6]
[![status dependensi pengembang][7]][8]
[![Lisensi][license-image]][license-url]
[![Pengunduhan][downloads-image]][downloads-url]

[![lencana npm][11]][1]

Pustaka penguraian querystring dan pengubahan menjadi string dengan beberapa keamanan tambahan.

Pengelola Utama: [Jordania Harband](https://github.com/ljharb)

Modul **qs** awalnya dibuat dan dikelola oleh [TJ Holowaychuk](https://github.com/visionmedia/node-querystring).

## <a name="usage"></a>Penggunaan

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>Mengurai Objek

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** memungkinkan Anda membuat objek berlapis di dalam string kueri, dengan mengapit nama sub-kunci dengan tanda kurung siku `[]`.
Misalnya, string `'foo[bar]=baz'` dikonversi menjadi:

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

Saat menggunakan opsi `plainObjects`, nilai yang diuraikan dikembalikan sebagai objek null, dibuat melalui `Object.create(null)` dan karena itu Anda harus menyadari bahwa metode prototipe tidak akan ada di sana dan pengguna dapat mengatur nama tersebut ke nilai apa pun yang mereka suka:

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

Secara default, parameter yang akan menimpa properti pada prototipe objek diabaikan, jika Anda ingin menyimpan data dari bidang tersebut, gunakan `plainObjects` seperti yang disebutkan di atas, atau atur `allowPrototypes` ke `true` yang akan memungkinkan input pengguna untuk menimpa properti tersebut. *PERINGATAN* Mengaktifkan opsi ini biasanya merupakan ide yang buruk karena dapat menyebabkan masalah saat mencoba menggunakan properti yang telah ditimpa. Sebaiknya Anda selalu berhati-hati dengan opsi ini.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

String yang dikodekan URI juga berfungsi:

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

Anda juga dapat menyarangkan objek, seperti `'foo[bar][baz]=foobarbaz'`:

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

Secara default, ketika menyarangkan **qs** objek hanya akan mengurai hingga 5 turunan. Hal ini berarti jika Anda mencoba mengurai string seperti `'a[b][c][d][e][f][g][h][i]=j'`, objek yang dihasilkan adalah:

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

Kedalaman ini dapat diganti dengan meneruskan opsi `depth` ke `qs.parse(string, [options])`:

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

Batas kedalaman membantu mengurangi penyalahgunaan saat **qs** digunakan untuk mengurai input pengguna, dan disarankan untuk menyimpannya dalam jumlah yang cukup kecil.

Untuk alasan serupa, secara default **qs** hanya akan mengurai hingga 1000 parameter. Hal ini dapat ditimpa dengan memberikan opsi `parameterLimit`:

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

Untuk mengabaikan tanda tanya di depan, gunakan `ignoreQueryPrefix`:

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

Pemisah opsional juga dapat dilewati:

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

Pemisah juga dapat menjadi regex:

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

Opsi `allowDots` dapat digunakan untuk mengaktifkan notasi titik:

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

Jika Anda harus berurusan dengan browser atau layanan yang lama, ada juga dukungan untuk mendekode oktet yang dikodekan persen sebagai iso-8859-1:

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

Beberapa layanan menambahkan nilai `utf8=✓` awal ke formulir sehingga versi Internet Explorer lama lebih cenderung mengirimkan formulir sebagai utf-8. Selain itu, server dapat memeriksa nilai terhadap pengodean yang salah dari karakter tanda centang dan mendeteksi bahwa string kueri atau isi `application/x-www-form-urlencoded`, misalnya *tidak* dikirim sebagai utf-8. jika formulir memiliki parameter `accept-charset` atau halaman yang memuat formulir memiliki tataan karakter yang berbeda.

**qs** mendukung mekanisme ini melalui opsi `charsetSentinel`.
Jika ditentukan, parameter `utf8` akan dihilangkan dari objek yang dikembalikan. Hal ini akan digunakan untuk beralih ke mode `iso-8859-1`/`utf-8` bergantung pada cara tanda centang dikodekan.

**Penting**: Saat Anda menentukan opsi `charset` dan opsi `charsetSentinel`, `charset` akan ditimpa jika permintaan berisi parameter `utf8` yang darinya tataan karakter sebenarnya dapat disimpulkan. Oleh karena itu, `charset` akan berperilaku sebagai tataan karakter default daripada tataan karakter otoritatif.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

Jika Anda ingin mendekode sintaks `&#...;` ke karakter sebenarnya, Anda juga dapat menentukan opsi `interpretNumericEntities`:

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

Hal ini juga berfungsi ketika tataan karakter terdeteksi dalam mode `charsetSentinel`.

### <a name="parsing-arrays"></a>Mengurai Array

**qs** juga dapat mengurai array menggunakan notasi `[]` yang serupa:

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

Anda juga dapat menentukan indeks:

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

Perhatikan bahwa satu-satunya perbedaan antara indeks dalam array dan kunci dalam objek adalah bahwa nilai di antara tanda kurung harus berupa angka untuk membuat array. Saat membuat array dengan indeks tertentu, **qs** akan memadatkan array rongga ke hanya nilai yang ada yang mempertahankan urutannya:

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

Anda juga dapat menggunakan opsi `allowSparse` untuk mengurai array rongga:

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

Perhatikan bahwa string kosong juga merupakan nilai, dan akan dipertahankan:

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** juga akan membatasi dalam menentukan indeks di array hingga indeks maksimum `20`. Setiap anggota array dengan indeks lebih besar dari `20` akan dikonversi menjadi objek dengan indeks sebagai kuncinya. Hal ini diperlukan untuk menangani kasus ketika seseorang mengirim, misalnya, `a[999999999]` dan akan membutuhkan waktu yang signifikan untuk mengulangi array besar ini.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

Batas ini dapat diganti dengan memberikan opsi `arrayLimit`:

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

Untuk menonaktifkan penguraian array seluruhnya, atur `parseArrays` ke `false`.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

Jika Anda mencampur notasi, **qs** akan menggabungkan dua item menjadi objek:

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

Anda juga dapat membuat array objek:

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

Beberapa orang menggunakan koma untuk menggabungkan array, **qs** dapat menguraikannya:
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_hal ini tidak dapat mengonversi objek berlapis, seperti `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>Mengubah menjadi string

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

Saat mengubah menjadi string, **qs** secara default, URI mengodekan output. Objek diubah menjadi string seperti yang Anda harapkan:

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

Pengodean ini dapat dinonaktifkan dengan mengatur opsi `encode` ke `false`:

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

Pengodean dapat dinonaktifkan untuk kunci dengan mengatur opsi `encodeValuesOnly` ke `true`:
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

Pengodean ini juga dapat diganti dengan metode pengodean kustom yang ditetapkan sebagai opsi `encoder`:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(Catatan: opsi `encoder` tidak berlaku jika `encode` adalah `false`)_

Analog dengan `encoder` terdapat opsi `decoder` untuk `parse` guna mengganti pendekodean properti dan nilai:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

Anda dapat mengodekan kunci dan nilai menggunakan logika yang berbeda dengan menggunakan argumen jenis yang disediakan untuk penyandi:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

Argumen jenis juga disediakan untuk dekoder:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

Contoh di luar titik ini akan ditampilkan seolah-olah output bukan URI yang dikodekan untuk kejelasan. Perhatikan bahwa nilai yang dikembalikan dalam kasus ini *akan* dikodekan URI selama penggunaan sebenarnya.

Ketika array diubah menjadi string, secara default array diberikan indeks eksplisit:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

Anda dapat menimpanya dengan mengatur opsi `indices` ke `false`:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

Anda dapat menggunakan opsi `arrayFormat` untuk menentukan format array output:

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

Ketika objek diubah menjadi string, secara default objek menggunakan notasi braket:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

Anda dapat mengganti hal ini agar menggunakan notasi titik dengan mengatur opsi `allowDots` ke `true`:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

String kosong dan nilai null akan menghilangkan nilai, tetapi tanda sama dengan (=) tetap berada di tempatnya:

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

Kunci tanpa nilai (seperti objek atau array kosong) tidak akan menghasilkan apa-apa:

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

Properti yang diatur ke `undefined` akan dihilangkan seluruhnya:

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

String kueri secara opsional dapat diawali dengan tanda tanya:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

Pemisah dapat diganti dengan stringify juga:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

Jika Anda hanya ingin mengganti serialisasi objek `Date`, Anda dapat memberikan opsi `serializeDate`:

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

Anda dapat menggunakan opsi `sort` untuk memengaruhi urutan kunci parameter:

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

Terakhir, Anda dapat menggunakan opsi `filter` untuk membatasi kunci mana yang akan disertakan dalam output yang diubah menjadi string.
Jika Anda meneruskan fungsi, fungsi akan dipanggil untuk setiap kunci untuk mendapatkan nilai pengganti. Atau, jika Anda meneruskan array, array akan digunakan untuk memilih properti dan indeks array untuk pengubahan string:

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>Menangani nilai `null`

Secara default, nilai `null` diperlakukan seperti string kosong:

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

Penguraian tidak membedakan antara parameter dengan dan tanpa tanda sama dengan. Keduanya dikonversi menjadi string kosong.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

Untuk membedakan antara nilai `null` dan string kosong, gunakan bendera `strictNullHandling`. Dalam string hasil, nilai `null` tidak memiliki tanda `=`:

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

Untuk mengurai nilai tanpa `=` kembali ke `null` gunakan bendera `strictNullHandling`:

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

Untuk sepenuhnya melewati kunci perenderan dengan nilai `null`, gunakan bendera `skipNulls`:

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

Jika Anda berkomunikasi dengan sistem yang lama, Anda dapat beralih ke `iso-8859-1` menggunakan opsi `charset`:

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

Karakter yang tidak ada di `iso-8859-1` akan dikonversi menjadi entitas numerik, mirip dengan apa yang dilakukan browser:

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

Anda dapat menggunakan opsi `charsetSentinel` untuk mengumumkan karakter dengan menyertakan parameter `utf8=✓` dengan pengodean yang tepat jika tanda centang, mirip dengan apa yang dilakukan Ruby on Rails dan lainnya saat mengirimkan formulir.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>Mengatasi tataan karakter khusus

Secara default, pengodean dan pendekodean karakter dilakukan di `utf-8`, dan dukungan `iso-8859-1` juga dibangun melalui parameter `charset`.

Jika Anda ingin mengodekan querystring ke tataan karakter yang berbeda (yaitu [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS)), Anda dapat menggunakan pustaka [`qs-iconv`](https://github.com/martinheidegger/qs-iconv):

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

Hal ini juga berfungsi untuk pendekodean string kueri:

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>Pengodean ruang RFC 3986 dan RFC 1738

RFC3986 digunakan sebagai opsi default dan mengodekan ' ' ke *%20* yang kompatibel dengan versi sebelumnya.
Pada saat yang sama, output dapat diubah menjadi string sesuai RFC1738 dengan ' ' sama dengan '+'.

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>Keamanan

Kirim email ke [@ljharb](https://github.com/ljharb) atau lihat https://tidelift.com/security jika Anda memiliki potensi kerentanan keamanan untuk dilaporkan.

## <a name="qs-for-enterprise"></a>qs untuk perusahaan

Tersedia sebagai bagian dari Langganan Tidelift

Pengelola qs dan ribuan paket lainnya bekerja dengan Tidelift untuk memberikan dukungan komersial dan pemeliharaan untuk dependensi sumber terbuka yang Anda gunakan untuk membangun aplikasi Anda. Hemat waktu, kurangi risiko, dan tingkatkan kesehatan kode, sambil membayar pengelola dependensi yang sesuai yang Anda gunakan. [Pelajari lebih lanjut.](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
