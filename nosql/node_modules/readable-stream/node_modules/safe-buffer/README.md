---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052992"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![unduhan][downloads-image]][downloads-url] [![panduan gaya javascript][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>API Buffer Node.js yang Lebih Aman

**Menggunakan API Buffer Node.js baru (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) di semua versi Node.js.**

**Menggunakan implementasi bawaan jika tersedia.**

## <a name="install"></a>Instal

```
npm install safe-buffer
```

## <a name="usage"></a>penggunaan

Tujuan paket ini adalah menyediakan pengganti yang aman untuk node.js `Buffer`.

Ini adalah pengganti drop-in untuk `Buffer`. Anda dapat menggunakannya dengan menambahkan satu baris `require` ke bagian atas modul node.js Anda:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Metode Kelas: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Mengalokasikan `Buffer` baru menggunakan `array` oktet.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

`TypeError` akan muncul jika `array` bukan `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Metode Kelas: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} Properti `.buffer` dari `TypedArray` atau `new ArrayBuffer()`
* `byteOffset` {Number} Default: `0`
* `length` {Number} Default: `arrayBuffer.length - byteOffset`

Saat meneruskan referensi ke properti `.buffer` dari instans `TypedArray`, `Buffer` yang baru dibuat akan berbagi memori yang dialokasikan yang sama dengan TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Argumen `byteOffset` dan `length` opsional menentukan rentang memori dalam `arrayBuffer` yang akan digunakan bersama oleh `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

`TypeError` akan muncul jika `arrayBuffer` bukan `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Metode Kelas: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Menyalin data `buffer` yang diteruskan ke instans `Buffer` baru.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

`TypeError` akan muncul jika `buffer` bukan `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Metode Kelas: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} String yang akan dikodekan.
* `encoding` {String} Pengodean yang akan digunakan, Default: `'utf8'`

Membuat `Buffer` baru yang berisi string JavaScript `str` yang diberikan. Jika disediakan, parameter `encoding` mengidentifikasi pengodean karakter.
Jika tidak disediakan, default `encoding` diatur ke `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

`TypeError` akan muncul jika `str` bukan string.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Metode Kelas: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} Default: `undefined`
* `encoding` {String} Default: `utf8`

Mengalokasikan `Buffer` baru dari `size` byte. Jika `fill` adalah `undefined`, `Buffer` akan *diisi nol*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` harus kurang dari atau sama dengan nilai `require('buffer').kMaxLength` (pada arsitektur 64-bit, `kMaxLength` adalah `(2^31)-1`). Jika tidak, [`RangeError`][] akan muncul. Buffer dengan panjang nol akan dibuat jika `size` kurang dari atau sama dengan 0 ditentukan.

Jika `fill` ditentukan, `Buffer` yang dialokasikan akan diinisialisasi dengan memanggil `buf.fill(fill)`. Lihat [`buf.fill()`][] untuk informasi selengkapnya.

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Jika `fill` dan `encoding` ditentukan, `Buffer` yang dialokasikan akan diinisialisasi dengan memanggil `buf.fill(fill, encoding)`. Contohnya:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

Memanggil `Buffer.alloc(size)` bisa jauh lebih lambat daripada alternatif `Buffer.allocUnsafe(size)` tetapi dapat memastikan bahwa konten instans `Buffer` yang baru dibuat *tidak akan pernah berisi data sensitif*.

`TypeError` akan muncul jika `size` bukan angka.

### <a name="class-method-bufferallocunsafesize"></a>Metode Kelas: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Mengalokasikan *tidak berisi nol* `Buffer` baru dari `size` byte.  `size` harus kurang dari atau sama dengan nilai `require('buffer').kMaxLength` (pada arsitektur 64-bit, `kMaxLength` adalah `(2^31)-1`). Jika tidak, [`RangeError`][] akan muncul. Buffer dengan panjang nol akan dibuat jika `size` kurang dari atau sama dengan 0 ditentukan.

Memori yang mendasari untuk instans `Buffer` yang dibuat dengan cara ini *tidak diinisialisasi*. Konten `Buffer` yang baru dibuat tidak diketahui dan *mungkin berisi data sensitif*. Gunakan [`buf.fill(0)`][] untuk menginisialisasi instans `Buffer` tersebut ke nol.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`TypeError` akan muncul jika `size` bukan angka.

Perhatikan bahwa modul `Buffer` telah mengalokasikan terlebih dahulu instans `Buffer` internal berukuran `Buffer.poolSize` yang digunakan sebagai kumpulan untuk alokasi cepat instans `Buffer` baru yang dibuat menggunakan `Buffer.allocUnsafe(size)` (dan konstruktor `new Buffer(size)` yang tidak digunakan lagi) hanya jika `size` kurang dari atau sama dengan `Buffer.poolSize >> 1` (lantai `Buffer.poolSize` dibagi dua). Nilai default `Buffer.poolSize` adalah `8192` tetapi dapat diubah.

Penggunaan kumpulan memori internal yang telah dialokasikan sebelumnya ini merupakan perbedaan utama antara memanggil `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`. Secara khusus, `Buffer.alloc(size, fill)` *tidak akan pernah* menggunakan kumpulan Buffer internal, sedangkan `Buffer.allocUnsafe(size).fill(fill)` *akan* menggunakan kumpulan Buffer internal jika `size` kurang dari atau sama dengan setengah `Buffer.poolSize`. Perbedaannya tidak kentara tetapi dapat menjadi penting jika aplikasi memerlukan performa tambahan yang disediakan `Buffer.allocUnsafe(size)`.

### <a name="class-method-bufferallocunsafeslowsize"></a>Metode Kelas: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Mengalokasikan *tidak berisi nol* dan tidak terkumpul `Buffer` baru dari `size` byte.  `size` harus kurang dari atau sama dengan nilai `require('buffer').kMaxLength` (pada arsitektur 64-bit, `kMaxLength` adalah `(2^31)-1`). Jika tidak, [`RangeError`][] akan muncul. Buffer dengan panjang nol akan dibuat jika `size` kurang dari atau sama dengan 0 ditentukan.

Memori yang mendasari untuk instans `Buffer` yang dibuat dengan cara ini *tidak diinisialisasi*. Konten `Buffer` yang baru dibuat tidak diketahui dan *mungkin berisi data sensitif*. Gunakan [`buf.fill(0)`][] untuk menginisialisasi instans `Buffer` tersebut ke nol.

Saat menggunakan `Buffer.allocUnsafe()` untuk mengalokasikan instans `Buffer` baru, alokasi di bawah 4 KB, secara default, dipotong dari satu `Buffer` yang telah dialokasikan sebelumnya. Hal ini memungkinkan aplikasi menghindari overhead pengumpulan sampah yang disebabkan karena membuat banyak Buffer yang dialokasikan secara terpisah. Pendekatan ini meningkatkan performa dan penggunaan memori dengan menghilangkan kebutuhan untuk melacak dan membersihkan sebanyak `Persistent` objek.

Namun, dalam kasus di mana pengembang mungkin perlu menyimpan sebagian kecil memori dari kumpulan untuk waktu yang tidak ditentukan, mungkin tepat untuk membuat instans Buffer yang tidak digabungkan menggunakan `Buffer.allocUnsafeSlow()` lalu menyalin bit yang relevan.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

Penggunaan `Buffer.allocUnsafeSlow()` harus digunakan hanya sebagai upaya terakhir *setelah* pengembang mengamati retensi memori yang tidak semestinya dalam aplikasi mereka.

`TypeError` akan muncul jika `size` bukan angka.

### <a name="all-the-rest"></a>Semua Sisanya

API `Buffer` lainnya sama persis seperti di node.js.
[Lihat dokumen](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Tautan terkait

- [Masalah Node.js: Buffer(number) tidak aman](https://github.com/nodejs/node/issues/4660)
- [Proposal Penyempurnaan Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() tidak digunakan lagi sementara](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Mengapa `Buffer` tidak aman?

Saat ini, konstruktor node.js `Buffer` kelebihan beban untuk menangani berbagai jenis argumen seperti `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, dll.), `ArrayBuffer`, dan juga `Number`.

API dioptimalkan untuk memberikan kenyamanan: Anda dapat memasukkan jenis apa pun ke dalamnya, dan API akan mencoba melakukan apa yang Anda inginkan.

Karena konstruktor Buffer sangat kuat, Anda sering melihat kode seperti ini:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Tetapi apa yang terjadi jika `toHex` dipanggil dengan argumen `Number`?***

### <a name="remote-memory-disclosure"></a>Pengungkapan Memori Jarak Jauh

Jika penyerang dapat membuat program Anda memanggil konstruktor `Buffer` dengan argumen `Number`, maka penyerang dapat membuatnya mengalokasikan memori yang tidak diinisialisasi dari proses node.js.
Hal ini berpotensi mengungkapkan kunci pribadi TLS, data pengguna, atau kata sandi database.

Saat konstruktor `Buffer` diteruskan argumen `Number`, konstruktor menampilkan blok memori **BATAL INISIALISASI** dari `size` yang ditentukan. Saat Anda membuat `Buffer` seperti ini, Anda **HARUS** menimpa konten sebelum menampilkannya ke pengguna.

Dari [dokumen node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - Nomor `size`
>
> Memori yang mendasari untuk instans `Buffer` yang dibuat dengan cara ini tidak diinisialisasi.
> **Konten `Buffer` yang baru dibuat tidak diketahui dan dapat berisi data sensitif.** Gunakan `buf.fill(0)` untuk menginisialisasi Buffer ke nol.

(Tekankan milik kita sendiri.)

Setiap kali pemrogram bermaksud membuat `Buffer` yang tidak diinisialisasi, Anda sering melihat kode seperti ini:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>Apakah ini akan menjadi masalah dalam kode yang sebenarnya?

Ya. Sangat umum untuk lupa memeriksa jenis variabel Anda dalam bahasa yang diketik secara dinamis seperti JavaScript.

Biasanya konsekuensi dari mengasumsikan jenis yang salah adalah bahwa program Anda mengalami crash dengan pengecualian yang tidak tertangkap. Namun, mode kegagalan karena lupa memeriksa jenis argumen ke konstruktor `Buffer` lebih berbahaya.

Berikut adalah contoh layanan rentan yang mengambil payload JSON dan mengubahnya menjadi hex:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

Dalam contoh ini, klien http hanya perlu mengirim:

```json
{
  "str": 1000
}
```

dan klien http akan mendapatkan kembali 1.000 byte memori yang tidak diinisialisasi dari server.

Ini adalah bug yang sangat serius. Tingkat keparahannya mirip dengan [bug Heartbleed](http://heartbleed.com/) yang memungkinkan pengungkapan memori proses OpenSSL oleh penyerang jarak jauh.


### <a name="which-real-world-packages-were-vulnerable"></a>Paket dunia nyata mana yang rentan?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) dan saya ([Feross Aboukhadijeh](http://feross.org/)) menemukan masalah ini di salah satu paket kami sendiri, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). Bug akan memungkinkan siapa saja di internet mengirim serangkaian pesan ke pengguna `bittorrent-dht` dan membuat mereka mengungkapkan 20 byte pada saat memori yang tidak diinisialisasi dari proses node.js.

Berikut [penerapan](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) yang memperbaikinya. Kami merilis versi baru yang telah diperbaiki, membuat [Pengungkapan Proyek Keamanan Node](https://nodesecurity.io/advisories/68), dan menghentikan semua versi yang rentan pada npm sehingga pengguna akan mendapatkan peringatan untuk meningkatkan ke versi yang lebih baru.

#### [`ws`](https://www.npmjs.com/package/ws)

Hal ini membuat kami bertanya-tanya apakah ada paket rentan lainnya. Benar saja, dalam waktu singkat, kami menemukan masalah yang sama di [`ws`](https://www.npmjs.com/package/ws), implementasi WebSocket paling populer di node.js.

Jika API tertentu dipanggil dengan parameter `Number`, bukan `String` atau `Buffer` seperti yang diharapkan, maka memori server yang tidak diinisialisasi akan diungkapkan ke serekan jarak jauh.

Ini adalah metode yang rentan:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Berikut server soket yang rentan dengan beberapa fungsi echo:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

`socket.send(number)` dipanggil di server, akan mengungkapkan memori server.

Berikut [rilis](https://github.com/websockets/ws/releases/tag/1.0.1) dengan masalah yang telah diperbaiki, dengan penjelasan yang lebih mendetail. Kami mengapresiasi [Arnout Kazemier](https://github.com/3rd-Eden) karena telah memperbaikinya dengan cepat. Berikut [Pengungkapan Proyek Keamanan Node](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Apa solusinya?

Sangat penting bahwa node.js menawarkan cara cepat untuk mendapatkan memori, jika tidak, aplikasi yang penting bagi performa akan menjadi jauh lebih lambat.

Namun, kami membutuhkan cara yang lebih baik untuk *menunjukkan niat kami* sebagai pemrogram. **Jika menginginkan memori yang tidak diinisialisasi, kita harus memintanya secara eksplisit.**

Fungsionalitas sensitif tidak boleh dikemas ke dalam API ramah pengembang yang secara longgar menerima banyak jenis berbeda. Jenis API ini mendorong praktik malas, yakni meneruskan variabel tanpa memeriksa jenisnya dengan sangat hati-hati.

#### <a name="a-new-api-bufferallocunsafenumber"></a>API baru: `Buffer.allocUnsafe(number)`

Fungsionalitas membuat buffer dengan memori yang tidak diinisialisasi harus menjadi bagian dari API lain. Kami mengusulkan `Buffer.allocUnsafe(number)`. Dengan begitu, fungsionalitas ini bukan bagian dari API yang sering mendapatkan input pengguna dari berbagai jenis yang diteruskan ke dalamnya.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Bagaimana cara memperbaiki core node.js?

Kami mengirim [PR ke core node.js](https://github.com/nodejs/node/pull/4514) (digabung menjadi `semver-major`) yang melindungi agar terhindar dari satu kasus:

```js
var str = 16
new Buffer(str, 'utf8')
```

Dalam situasi ini, tersirat bahwa pemrogram membuat argumen pertama menjadi string, karena mereka meneruskan pengodean sebagai argumen kedua. Kali ini, node.js akan mengalokasikan memori yang tidak diinisialisasi dalam kasus `new Buffer(number, encoding)`, yang mungkin bukan yang dimaksudkan oleh pemrogram.

Tapi ini hanya solusi parsial, karena jika pemrogram membuat `new Buffer(variable)` (tanpa parameter `encoding`) tidak ada cara untuk mengetahui apa tujuannya. Jika `variable` terkadang berupa angka, maka memori yang tidak diinisialisasi terkadang akan ditampilkan.

### <a name="whats-the-real-long-term-fix"></a>Apa perbaikan jangka panjang yang sebenarnya?

Kami dapat menghentikan dan menghapus `new Buffer(number)` dan menggunakan `Buffer.allocUnsafe(number)` saat kami membutuhkan memori yang tidak diinisialisasi. Tapi hal tersebut akan memecahkan 1000-an paket.

~~Kami yakin solusi terbaiknya adalah:~~

~~1. Mengubah `new Buffer(number)` untuk menampilkan memori yang aman dan kosong~~

~~2. Membuat API baru untuk membuat Buffer yang tidak diinisialisasi. Kami mengusulkan: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Pembaruan

Kami sekarang mendukung penambahan tiga API baru:

- `Buffer.from(value)` - mengonversi dari jenis apa pun ke buffer
- `Buffer.alloc(size)` - membuat buffer yang berisi nol
- `Buffer.allocUnsafe(size)` - membuat buffer yang tidak diinisialisasi dengan ukuran tertentu

Hal ini memecahkan masalah inti yang memengaruhi `ws` dan `bittorrent-dht` yang merupakan `Buffer(variable)` yang tertipu untuk mengambil argumen angka.

Dengan cara ini, kode yang ada terus bekerja dan dampaknya pada ekosistem npm akan minimal. Seiring waktu, pengelola npm dapat memigrasikan kode yang penting bagi performa untuk menggunakan `Buffer.allocUnsafe(number)`, bukan `new Buffer(number)`.


### <a name="conclusion"></a>Kesimpulan

Kami rasa ada masalah desain yang serius dengan API `Buffer` saat ini. Desain ini mempromosikan perangkat lunak yang tidak aman dengan menempatkan fungsionalitas berisiko tinggi ke dalam API yang praktis dengan "ergonomika pengembang" yang ramah.

API ini bukan hanya latihan teoretis karena kami menemukan masalah di beberapa paket npm paling populer.

Untungnya, ada perbaikan mudah yang dapat diterapkan hari ini. Gunakan `safe-buffer` sebagai ganti `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

Pada akhirnya, kami berharap core node.js dapat beralih ke perilaku baru yang lebih aman ini. Kami yakin dampaknya terhadap ekosistem akan minimal karena ini bukan perubahan yang merusak.
Paket populer yang terpelihara dengan baik akan diperbarui untuk menggunakan `Buffer.alloc` dengan cepat, sementara paket lama yang tidak aman akan secara ajaib menjadi aman dari vektor serangan ini.


## <a name="links"></a>links

- [PR Node.js: buffer: muncul jika panjang dan enc diteruskan](https://github.com/nodejs/node/pull/4514)
- [Pengungkapan Proyek Keamanan Node untuk `ws`](https://nodesecurity.io/advisories/67)
- [Pengungkapan Proyek Keamanan Node untuk`bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>kredit

Masalah asli dalam `bittorrent-dht` ([pengungkapan](https://nodesecurity.io/advisories/68)) dan `ws` ([pengungkapan](https://nodesecurity.io/advisories/67)) ditemukan oleh [Mathias Buus](https://github.com/mafintosh) dan [Feross Aboukhadijeh](http://feross.org/).

Terima kasih kepada [Adam Baldwin](https://github.com/evilpacket) karena telah membantu mengungkap masalah ini dan atas upayanya dalam menjalankan [Proyek Keamanan Node](https://nodesecurity.io/).

Terima kasih kepada [John Hiesey](https://github.com/jhiesey) karena telah mengoreksi README ini dan mengaudit kodenya.


## <a name="license"></a>lisensi

MIT. Hak Cipta (C) [Feross Aboukhadijeh](http://feross.org)
