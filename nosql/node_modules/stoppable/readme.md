---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051586"
---
# <a name="stoppable"></a>dapat dihentikan

[![Status Build](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> Node `server.close()` seperti yang Anda [harapkan berfungsi secara default](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Ringkasan

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Penghentian yang dapat dihentikan menerima koneksi baru dan menutup koneksi tidak aktif yang ada (termasuk keep-alives) tanpa menghentikan permintaan yang sedang berlangsung.

## <a name="requirements"></a>Persyaratan

- Node.js v6+

Node.js v4.x *tidak resmi* didukung.

## <a name="installation"></a>Penginstalan

```bash
yarn add stoppable
```

(atau gunakan npm)

## <a name="usage"></a>Penggunaan

**konstruktor**

```js
stoppable(server, grace)
```

Menghias instans server dengan metode `stop`.
Mengembalikan instans server, sehingga dapat dirantai, atau dapat dijalankan sebagai pernyataan mandiri.

- server: Setiap contoh HTTP atau HTTPS Server
- tenggang: Milidetik untuk menunggu sebelum koneksi menutup paksa

`grace` diatur secara default ke Infinity (jangan tutup paksa).
Jika Anda ingin segera mematikan semua soket, Anda dapat menggunakan tenggang 0.

**stop()**

```js
server.stop(callback)
```

Menutup server.

- panggilan balik: diteruskan ke fungsi `server.close` yang ada untuk mendaftarkan otomatis acara 'tutup'.
Agrumen pertama adalah kesalahan, dan argumen kedua adalah boolean yang menunjukkan apakah berhenti dengan baik.

## <a name="design-decisions"></a>Keputusan desain

- Patching monyet umumnya menyebalkan, tetapi dalam hal ini adalah API terbaik. Sebut saja "dekorasi".
- `grace` dapat ditentukan pada `stop`, tetapi lebih baik untuk mencocokkan `server.close` API yang ada.
- Klien harus ditangani dengan hormat, jadi kami tidak hanya menghancurkan soket, kami mengirimkan paket `FIN` terlebih dahulu.
- Setiap solusi untuk masalah ini memerlukan pembukuan pada setiap koneksi dan permintaan/tanggapan.
Kami melakukan pekerjaan minimum pada jalur kode "panas" ini dan menunda sebanyak mungkin ke metode `stop` yang sebenarnya.

## <a name="performance"></a>Performa

Tidak ada cara untuk menyediakan fungsionalitas ini tanpa pembukuan koneksi, pemutusan, permintaan, dan respons.
Namun, Stoppable berusaha untuk melakukan pekerjaan minimal di jalur kode panas dan menggunakan struktur data yang optimal.

Saya tertarik untuk melihat tolok ukur performa dunia nyata; tolok ukur artileri perulangan sederhana yang disertakan dalam pustaka menunjukkan sedikit overhead dari penggunaan server yang dapat dihentikan:

### <a name="without-stoppable"></a>Tanpa Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Dengan Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Lisensi

MIT