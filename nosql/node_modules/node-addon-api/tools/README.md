---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051205"
---
# <a name="tools"></a>Alat

## <a name="clang-format"></a>clang-format

Alat pemeriksa clang-format dirancang untuk memeriksa baris kode yang diubah dibandingkan dengan referensi git yang diberikan.

## <a name="migration-script"></a>Skrip Migrasi

Alat migrasi dirancang untuk mengurangi pekerjaan berulang dalam proses migrasi. Namun, skrip tidak bertujuan untuk mengonversi semuanya untuk Anda. Biasanya ada beberapa perbaikan kecil dan rekonstruksi besar yang diperlukan.

### <a name="how-to-use"></a>Cara Penggunaan

Untuk menjalankan skrip konversi, pertama-tama pastikan Anda memiliki `node-addon-api` terbaru di direktori `node_modules` Anda.
```
npm install node-addon-api
```

Kemudian, jalankan skrip yang melewati direktori proyek Anda
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

Setelah selesai, kompilasi ulang dan debug hal-hal yang terlewatkan oleh skrip.


### <a name="quick-fixes"></a>Perbaikan Cepat
Berikut adalah daftar hal-hal yang dapat diperbaiki dengan mudah.
  1. Ubah nilai pengembalian metode Anda menjadi batal jika tidak mengembalikan nilai ke JavaScript.
  2. Gunakan `.` untuk mengakses atribut atau memanggil fungsi anggota di Napi::Object, bukan `->`.
  3. `Napi::New(env, value);` ke `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>Rekonstruksi Besar
Implementasi `Napi::ObjectWrap` sangat berbeda dengan NAN. `Napi::ObjectWrap` mengambil pointer ke objek yang dibungkus dan membuat referensi ke objek yang dibungkus di dalam konstruktor ObjectWrap. `Napi::ObjectWrap` juga mengaitkan metode instans objek yang dibungkus ke modul Javascript alih-alih metode statis seperti NAN.

Jadi, jika Anda menggunakan Nan::ObjectWrap di modul Anda, Anda harus menjalankan langkah-langkah berikut.

  1. Ubah fungsi [ClassName]::New Anda menjadi fungsi konstruktor yang menggunakan `Napi::CallbackInfo`. Nyatakan sebagai
```
[ClassName](const Napi::CallbackInfo& info);
```
dan definisikan sebagai
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
Dengan cara ini, konstruktor `Napi::ObjectWrap` akan dipanggil setelah objek dibuat dan `Napi::ObjectWrap` dapat menggunakan penunjuk `this` untuk membuat referensi ke objek yang dibungkus.

  2. Pindahkan kode konstruktor asli Anda ke konstruktor baru. Hapus konstruktor asli Anda.
  3. Dalam fungsi inisialisasi kelas Anda, kaitkan metode asli dengan cara berikut.
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. Dalam fungsi saat Anda perlu Membuka ObjectWrap di NAN seperti `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`, gunakan pointer `this` secara langsung sebagai objek yang tidak dibungkus karena setiap instans ObjectWrap dikaitkan dengan instans objek unik.


Jika Anda masih menemukan masalah setelah mengikuti panduan ini, ajukan masalah kepada kami yang menjelaskan masalah Anda dan kami akan mencoba menyelesaikannya.
