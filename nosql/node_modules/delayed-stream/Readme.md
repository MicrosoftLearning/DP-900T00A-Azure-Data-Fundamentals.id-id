---
ms.openlocfilehash: 21db9b7ec97b7028a031a18867aab00575b09850
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053018"
---
# <a name="delayed-stream"></a>delayed-stream

Peristiwa buffer dari aliran hingga Anda siap untuk menanganinya.

## <a name="installation"></a>Penginstalan

``` bash
npm install delayed-stream
```

## <a name="usage"></a>Penggunaan

Contoh berikut menunjukkan cara menulis server echo http yang menunda responsnya hingga 1000 md.

``` javascript
var DelayedStream = require('delayed-stream');
var http = require('http');

http.createServer(function(req, res) {
  var delayed = DelayedStream.create(req);

  setTimeout(function() {
    res.writeHead(200);
    delayed.pipe(res);
  }, 1000);
});
```

Jika tidak menggunakan `Stream#pipe`, Anda juga dapat melepaskan peristiwa yang di-buffer secara manual dengan memanggil `delayedStream.resume()`:

``` javascript
var delayed = DelayedStream.create(req);

setTimeout(function() {
  // Emit all buffered events and resume underlaying source
  delayed.resume();
}, 1000);
```

## <a name="implementation"></a>Penerapan

Untuk menggunakan aliran meta ini dengan benar, berikut adalah beberapa hal yang harus Anda ketahui tentang implementasinya.

### <a name="event-buffering--proxying"></a>Buffer/Proksi Peristiwa

Semua peristiwa aliran `source` dibajak dengan menimpa metode `source.emit`. Sampai node mengimplementasikan pemerhati kejadian catch-all, ini adalah satu-satunya cara.

Namun, delayed-stream masih terus mengirimkan semua peristiwa yang diambil di `source`, terlepas dari apakah Anda telah merilis aliran tertunda atau belum.

Setelah dibuat, delayed-stream mengambil semua peristiwa `source` dan menyimpannya dalam buffer peristiwa internal. Setelah `delayedStream.release()` dipanggil, semua acara yang di-buffer dikirimkan pada `delayedStream`, dan buffer acara dihapus. Setelah itu, delayed-stream hanya berfungsi sebagai proksi untuk sumber yang mendasari.

### <a name="error-handling"></a>Penanganan kesalahan

Peristiwa kesalahan pada `source` di-buffer diproksi sama seperti peristiwa lainnya.
Namun, `delayedStream.create` melampirkan pendengar `'error'` tanpa operasi ke `source`. Dengan cara ini, Anda hanya perlu menangani kesalahan pada objek `delayedStream`, bukan di dua tempat.

### <a name="buffer-limits"></a>Batas buffer

delayed-stream menyediakan properti `maxDataSize` yang dapat digunakan untuk membatasi jumlah data yang di-buffer. Untuk melindungi Anda dari aliran `source` buruk yang tidak bereaksi terhadap `source.pause()`, fitur ini diaktifkan secara default.

## <a name="api"></a>API

### <a name="delayedstreamcreatesource-options"></a>DelayedStream.create(source, [options])

Mengembalikan `delayedStream` baru. Opsi yang tersedia adalah:

* `pauseStream`
* `maxDataSize`

Deskripsi untuk properti tersebut dapat ditemukan di bawah.

### <a name="delayedstreamsource"></a>delayedStream.source

Aliran `source` dikelola oleh objek ini. Ini berguna jika Anda meneruskan `delayedStream` Anda, dan Anda masih ingin mengakses properti pada objek `source`.

### <a name="delayedstreampausestream--true"></a>delayedStream.pauseStream = true

Apakah akan menjeda `source` yang mendasari saat memanggil `DelayedStream.create()`. Memodifikasi properti ini setelahnya tidak akan berpengaruh.

### <a name="delayedstreammaxdatasize--1024--1024"></a>delayedStream.maxDataSize = 1024 * 1024

Jumlah data yang akan di-buffer sebelum mengirimkan `error`.

Jika sumber yang mendasari mengirimkan objek `Buffer`, `maxDataSize` mengacu pada byte.

Jika sumber yang mendasari mengirimkan string JavaScript, ukurannya mengacu pada karakter.

Jika Anda tahu apa yang Anda lakukan, Anda dapat mengatur properti ini ke `Infinity` untuk menonaktifkan fitur ini. Anda juga dapat memodifikasi properti ini selama runtime bahasa umum.

### <a name="delayedstreamdatasize--0"></a>delayedStream.dataSize = 0

Jumlah data yang di-buffer sejauh ini.

### <a name="delayedstreamreadable"></a>delayedStream.readable

Getter ECMA5 yang mengembalikan nilai `source.readable`.

### <a name="delayedstreamresume"></a>delayedStream.resume()

Jika `delayedStream` belum dirilis sejauh ini, `delayedStream.release()` dipanggil.

Dalam kedua kasus, `source.resume()` dipanggil.

### <a name="delayedstreampause"></a>delayedStream.pause()

Panggilan `source.pause()`.

### <a name="delayedstreampipedest"></a>delayedStream.pipe(dest)

Panggil `delayedStream.resume()` lalu membuat proksi argumen ke `source.pipe`.

### <a name="delayedstreamrelease"></a>delayedStream.release()

Mengirimkan dan menghapus semua peristiwa yang telah di-buffer sejauh ini. Hal ini tidak melanjutkan sumber yang mendasari, gunakan `delayedStream.resume()` sebagai gantinya.

## <a name="license"></a>Lisensi

delayed-stream dilisensikan berdasarkan lisensi MIT.
