---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050990"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![Status Build](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)

Implementasi dari [JSON Web Signatures](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Hal ini dikembangkan terhadap `draft-ietf-jose-json-web-signature-08` dan mengimplementasikan seluruh spesifikasi **kecuali** X.509 penandatanganan/verifikasi Rantai Sertifikat (patch diterima).

Terdapat API sinkron (`jws.sign`, `jws.verify`) dan aliran (`jws.createSign`, `jws.createVerify`).

# <a name="install"></a>Instal

```bash
$ npm install jws
```

# <a name="usage"></a>Penggunaan

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Array algoritma yang didukung. Algoritma berikut saat ini didukung.

Nilai Parameter alg | Tanda Tangan Digital atau Algoritma MAC
----------------|----------------------------
HS256 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-256
HS384 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-384
HS512 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-512
RS256 | RSASSA menggunakan algoritme hash SHA-256
RS384 | RSASSA menggunakan algoritme hash SHA-384
RS512 | RSASSA menggunakan algoritme hash SHA-512
PS256 | RSASSA-PSS menggunakan algoritme hash SHA-256
PS384 | RSASSA-PSS menggunakan algoritme hash SHA-384
PS512 | RSASSA-PSS menggunakan algoritme hash SHA-512
ES256 | ECDSA menggunakan kurva P-256 dan algoritme hash SHA-256
ES384 | ECDSA menggunakan kurva P-384 dan algoritme hash SHA-384
ES512 | ECDSA menggunakan kurva P-521 dan algoritme hash SHA-512
tidak ada | Tidak ada tanda tangan digital atau nilai MAC yang disertakan

## <a name="jwssignoptions"></a>jws.sign(options)

(Sinkron) Mengembalikan JSON Web Signature untuk header dan payload.

Opsi:

* `header`
* `payload`
* `secret` atau `privateKey`
* `encoding` (Opsional, diatur secara default ke 'utf8')

`header` harus berupa objek dengan properti `alg`. `header.alg` harus merupakan salah satu nilai yang ditemukan di `jws.ALGORITHMS`. Lihat di atas untuk tabel algoritma yang didukung.

Jika `payload` bukan merupakan buffer atau string, maka akan dipaksa menjadi string menggunakan `JSON.stringify`.

Contoh

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(Sinkron) Mengembalikan `true` atau `false` untuk apakah tanda tangan cocok dengan rahasia atau kunci.

`signature` adalah Tanda Tangan JWS. `header.alg` harus berupa nilai yang ditemukan di `jws.ALGORITHMS`.
Lihat di atas untuk tabel algoritma yang didukung. `secretOrKey` adalah string atau buffer yang berisi rahasia untuk algoritma Kode Autentikasi Pesan Berbasis Hash, atau kunci umum yang dikodekan PEM untuk RSA dan ECDSA.

Perhatikan bahwa nilai `"alg"` dari header tanda tangan diabaikan.


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(Sinkron) Mengembalikan header yang didekodekan, payload yang didekodekan, dan bagian tanda tangan dari JWS Signature.

Mengembalikan objek dengan tiga properti, misalnya
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

Mengembalikan objek SignStream baru.

Opsi:

* `header` (diperlukan)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Opsional, diatur secara default ke 'utf8')

Selain `header`, semua opsi mengharapkan string atau buffer ketika nilainya diketahui sebelumnya, atau aliran untuk kenyamanan.
`key`/`privateKey`/`secret` juga dapat menjadi objek saat menggunakan kunci privat terenkripsi, lihat [dokumentasi kripto][encrypted-key-docs].

Contoh:

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

Mengembalikan objek VerifyStream baru.

Opsi:

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Opsional, diatur secara default ke 'utf8')

Semua opsi mengharapkan string atau buffer ketika nilainya diketahui sebelumnya, atau aliran untuk kenyamanan.

Contoh:

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Kelas: SignStream

`Readable Stream` yang mengirimkan peristiwa data tunggal (tanda tangan terhitung) saat selesai.

### <a name="event-done"></a>Peristiwa: 'selesai'
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

`Writable Stream` yang mengharapkan payload JWS. *Jangan*  gunakan jika Anda meneruskan opsi `payload` ke konstruktor.

Contoh:

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

`Writable Stream`. Mengharapkan rahasia JWS untuk HMAC, atau privateKey untuk ECDSA dan RSA. *Jangan*  gunakan jika Anda meneruskan opsi `secret` atau `key` ke konstruktor.

Contoh:

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Kelas: VerifyStream

Ini adalah `Readable Stream` yang mengirimkan peristiwa data tunggal, hasil untuk apakah tanda tangan tersebut valid atau tidak.

### <a name="event-done"></a>Peristiwa: 'selesai'
`function (valid, obj) { }`

`valid` adalah boolean untuk apakah tanda tangan tersebut valid atau tidak.

### <a name="verifiersignature"></a>verifier.signature

`Writable Stream` yang mengharapkan Tanda Tangan JWS. *Jangan*  gunakan jika Anda meneruskan opsi `signature` ke konstruktor.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

`Writable Stream` yang mengharapkan kunci umum atau rahasia. *Jangan*  gunakan jika Anda meneruskan opsi `key` atau `secret` ke konstruktor.

# <a name="todo"></a>TODO

* Sepertinya harus ada beberapa opsi/API praktis untuk mendefinisikan algoritma alih-alih harus selalu mendefinisikan objek header dengan `{ alg: 'ES512' }` atau apa pun.

* Dukungan X.509, ugh

# <a name="license"></a>Lisensi

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
