---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051477"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Build** | **Dependensi** |
|-----------|---------------|
| [![Status Build](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Status Dependensi](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Penerapan [JSON Web Token](https://tools.ietf.org/html/rfc7519).

JSON Web Token ini dikembangkan terhadap `draft-ietf-oauth-json-web-token-08`. JSON Web Token menggunakan [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>Instal

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Catatan migrasi

* [Dari v7 hingga v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Penggunaan

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Asinkron) Jika panggilan balik diberikan, panggilan balik dipanggil dengan `err` atau JWT.

(Sinkron) Menghasilkan JsonWebToken sebagai string

`payload` dapat berupa harfiah objek, buffer, atau string yang mewakili JSON yang valid. 
> **Perlu _diperhatikan_ bahwa** `exp` atau klaim lainnya hanya diatur jika payload merupakan harfiah objek. Buffer atau payload string tidak diperiksa untuk validitas JSON.

> Jika `payload` bukan merupakan buffer atau string, maka akan dipaksa menjadi string menggunakan `JSON.stringify`.

`secretOrPrivateKey` adalah string, buffer, atau objek yang berisi rahasia untuk algoritma Kode Autentikasi Pesan Berbasis Hash atau kunci privat yang dikodekan PEM untuk RSA dan ECDSA. Jika kunci privat dengan frase sandi, objek `{ key, passphrase }` dapat digunakan (berdasarkan [dokumentasi kripto](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)), dalam hal ini pastikan Anda meneruskan opsi `algorithm`.

`options`:

* `algorithm` (default: `HS256`)
* `expiresIn`: dinyatakan dalam detik atau string yang menjelaskan rentang waktu [zeit/ms](https://github.com/zeit/ms). 
  > Misal: `60`, `"2 days"`, `"10h"`, `"7d"`. Nilai numerik ditafsirkan sebagai hitungan detik. Jika Anda menggunakan string, pastikan Anda memberikan satuan waktu (hari, jam, dll), jika tidak, satuan milidetik digunakan secara default (`"120"` sama dengan `"120ms"`).
* `notBefore`: dinyatakan dalam detik atau string yang menjelaskan rentang waktu [zeit/ms](https://github.com/zeit/ms). 
  > Misal: `60`, `"2 days"`, `"10h"`, `"7d"`. Nilai numerik ditafsirkan sebagai hitungan detik. Jika Anda menggunakan string, pastikan Anda memberikan satuan waktu (hari, jam, dll), jika tidak, satuan milidetik digunakan secara default (`"120"` sama dengan `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: jika benar, fungsi tanda akan langsung mengubah objek payload. Hal ini berguna jika Anda memerlukan referensi mentah ke payload setelah klaim diterapkan pada payload tetapi sebelum dikodekan menjadi token.



> Tidak ada nilai default untuk `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  Klaim ini juga dapat diberikan dalam payload secara langsung dengan masing-masing `exp`, `nbf`, `aud`, `sub`, dan `iss`, tetapi Anda **_tidak dapat_** menyertakan di kedua tempat.

Perlu diingat bahwa `exp`, `nbf` dan `iat` adalah **NumericDate**, lihat [Kedaluwarsa Token (klaim exp)](#token-expiration-exp-claim) terkait


Header dapat disesuaikan melalui objek `options.header`.

Jwts yang dihasilkan akan menyertakan klaim `iat` (yang dikeluarkan) secara default kecuali `noTimestamp` ditentukan. Jika `iat` dimasukkan ke dalam payload, maka akan digunakan sebagai ganti dari stempel waktu sebenarnya untuk menghitung hal-hal lain seperti `exp` yang diberikan rentang waktu di `options.expiresIn`.

Tanda Sinkron dengan default (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Tanda Sinkron dengan RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Masuk secara asinkron
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Mengatur tanggal belakang jwt 30 detik
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Kedaluwarsa Token (klaim exp)

Standar untuk JWT menentukan klaim `exp` untuk kedaluwarsa. Kedaluwarsa direpresentasikan sebagai **NumericDate**:

> Nilai numerik JSON yang mewakili jumlah detik dari 1970-01-01T00:00:00Z UTC hingga tanggal/waktu UTC yang ditentukan, mengabaikan detik kabisat.  Hal ini setara dengan definisi IEEE Std 1003.1, Edisi 2013 [POSIX.1] "Seconds Since the Epoch", di mana setiap hari dihitung tepat 86400 detik, selain itu nilai yang bukan bilangan bulat dapat diwakili.  Lihat RFC 3339 [RFC3339] untuk detail mengenai tanggal/waktu pada umumnya dan pada khususnya UTC.

Hal ini berarti bahwa bidang `exp` harus berisi jumlah detik sejak jangka waktu.

Menandatangani token dengan 1 jam kedaluwarsa:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Cara lain untuk menghasilkan token seperti ini dengan pustaka ini adalah:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Asinkron) Jika panggilan balik diberikan, fungsi bertindak secara asinkron. Panggilan balik dipanggil dengan payload yang didekodekan jika tanda tangan valid dan kedaluwarsa bersifat opsional, audiens, atau pengeluar sertifikat valid. Jika tidak, panggilan balik akan dipanggil dengan kesalahan.

(Sinkron) Jika panggilan balik tidak diberikan, fungsi bertindak secara sinkron. Mengembalikan payload yang didekodekan jika tanda tangan valid dan kedaluwarsa bersifat opsional, audiens, atau pengeluar sertifikat valid. Jika tidak, panggilan balik akan memunculkan kesalahan.

`token` adalah string JsonWebToken

`secretOrPublicKey` adalah string atau buffer yang berisi rahasia untuk algoritma Kode Autentikasi Pesan Berbasis Hash, atau kunci umum yang dikodekan PEM untuk RSA dan ECDSA.
Jika `jwt.verify` disebut asinkron, `secretOrPublicKey` dapat berupa fungsi yang harus mengambil kunci rahasia atau umum. Lihat di bawah untuk contoh yang lebih detail

Seperti yang disebutkan dalam [komentar ini](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), ada pustaka lain yang mengharapkan rahasia dengan kode base64 (byte acak yang dikodekan menggunakan base64), jika demikian, Anda dapat meneruskan `Buffer.from(secret, 'base64')`, dengan melakukan hal ini, rahasia akan didekodekan menggunakan base64 dan verifikasi token akan menggunakan byte acak asli.

`options`

* `algorithms`: Daftar string dengan nama algoritma yang diizinkan. Contohnya, `["HS256", "HS384"]`.
* `audience`: jika Anda ingin memeriksa audiens (`aud`), berikan nilai di sini. Audiens dapat diperiksa terhadap string, regex atau daftar string dan/atau regex. 
  > Misal: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: menghasilkan objek dengan `{ payload, header, signature }` yang didekodekan, bukan hanya konten payload biasa.
* `issuer` (opsional): string atau array string nilai valid untuk bidang `iss`.
* `ignoreExpiration`: jika `true` tidak memvalidasi masa kedaluwarsa token.
* `ignoreNotBefore`...
* `subject`: jika Anda ingin memeriksa subjek (`sub`), berikan nilai di sini
* `clockTolerance`: jumlah detik untuk ditoleransi saat memeriksa klaim `nbf` dan `exp`, untuk menangani perbedaan jam yang kecil di antara server yang berbeda
* `maxAge`: usia maksimum yang diizinkan agar token tetap valid. Hal ini dinyatakan dalam detik atau string yang menjelaskan rentang waktu [zeit/ms](https://github.com/zeit/ms). 
  > Misal: `1000`, `"2 days"`, `"10h"`, `"7d"`. Nilai numerik ditafsirkan sebagai hitungan detik. Jika Anda menggunakan string, pastikan Anda memberikan satuan waktu (hari, jam, dll), jika tidak, satuan milidetik digunakan secara default (`"120"` sama dengan `"120ms"`).
* `clockTimestamp`: waktu dalam detik yang harus digunakan sebagai waktu saat ini untuk semua perbandingan yang diperlukan.
* `nonce`: jika Anda ingin memeriksa klaim `nonce`, berikan nilai string di sini. Ini digunakan pada ID Terbuka untuk Token ID. ([Catatan penerapan ID Terbuka](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Sinkron) Menghasilkan payload yang didekodekan tanpa memverifikasi apakah tanda tangan valid.

> __Peringatan:__ Hal ini __tidak__ akan memverifikasi apakah tanda tangan tersebut valid. Anda sebaiknya __tidak__ menggunakan ini untuk pesan yang tidak tepercaya. Anda kemungkinan besar ingin menggunakan `jwt.verify` sebagai gantinya.

`token` adalah string JsonWebToken

`options`:

* `json`: paksa JSON.parse pada payload meskipun header tidak berisi `"typ":"JWT"`.
* `complete`: menghasilkan objek dengan payload dan header yang didekode.

Contoh

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Kesalahan & Kode
Kemungkinan kesalahan yang dimunculkan selama verifikasi.
Kesalahan adalah argumen pertama dari panggilan balik verifikasi.

### <a name="tokenexpirederror"></a>TokenExpiredError

Kesalahan yang dimunculkan jika token kedaluwarsa.

Objek kesalahan:

* nama: 'TokenExpiredError'
* pesan: 'jwt kedaluwarsa'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Objek kesalahan:

* nama: 'JsonWebTokenError'
* pesan:
  * 'jwt rusak'
  * 'diperlukan tanda tangan jwt'
  * 'tanda tangan tidak valid'
  * 'audiens jwt tidak valid. yang diperlukan: [OPTIONS AUDIENCE]'
  * 'pengeluar sertifikat jwt tidak valid. yang diperlukan: [OPTIONS ISSUER]'
  * 'id jwt tidak valid. yang diperlukan: [OPTIONS JWT ID]'
  * 'subjek jwt tidak valid. yang diperlukan: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Dimunculkan jika waktu saat ini merupakan sebelum klaim nbf.

Objek kesalahan:

* nama: 'NotBeforeError'
* pesan: 'jwt tidak aktif'
* tanggal: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Algoritma yang didukung

Array algoritma yang didukung. Algoritma berikut saat ini didukung.

Nilai Parameter alg | Tanda Tangan Digital atau Algoritma MAC
----------------|----------------------------
HS256 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-256
HS384 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-384
HS512 | Kode Autentikasi Pesan Berbasis Hash menggunakan algoritme hash SHA-512
RS256 | RSASSA-PKCS1-v1_5 menggunakan algoritme hash SHA-256
RS384 | RSASSA-PKCS1-v1_5 menggunakan algoritme hash SHA-384
RS512 | RSASSA-PKCS1-v1_5 menggunakan algoritme hash SHA-512
PS256 | RSASSA-PSS menggunakan algoritme hash SHA-256 (hanya node ^6.12.0 ATAU >=8.0.0)
PS384 | RSASSA-PSS menggunakan algoritme hash SHA-384 (hanya node ^6.12.0 ATAU >=8.0.0)
PS512 | RSASSA-PSS menggunakan algoritme hash SHA-512 (hanya node ^6.12.0 ATAU >=8.0.0)
ES256 | ECDSA menggunakan kurva P-256 dan algoritme hash SHA-256
ES384 | ECDSA menggunakan kurva P-384 dan algoritme hash SHA-384
ES512 | ECDSA menggunakan kurva P-521 dan algoritme hash SHA-512
tidak ada | Tidak ada tanda tangan digital atau nilai MAC yang disertakan

## <a name="refreshing-jwts"></a>Merefresh JWT

Pertama-tama, sebaiknya Anda memastikan dengan hati-hati jika merefresh otomatis JWT tidak akan menimbulkan kerentanan apa pun di sistem Anda.

Kami merasa tidak nyaman memasukkan hal ini sebagai bagian dari pustaka, tetapi, Anda dapat melihat [contoh ini](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) untuk menunjukkan bagaimana hal ini dapat dicapai.
Selain contoh tersebut, ada [masalah](https://github.com/auth0/node-jsonwebtoken/issues/122) dan [permintaan pull](https://github.com/auth0/node-jsonwebtoken/pull/172) untuk mendapatkan lebih banyak pengetahuan tentang topik ini.

# <a name="todo"></a>TODO

* Rantai sertifikat X.509 tidak dicentang

## <a name="issue-reporting"></a>Pelaporan Masalah

Jika Anda menemukan bug atau jika Anda memiliki permintaan fitur, laporkan di bagian masalah repositori ini. Jangan laporkan kerentanan keamanan pada pelacak masalah GitHub publik. [Program Pengungkapan yang Bertanggung Jawab](https://auth0.com/whitehat) merinci prosedur untuk mengungkapkan masalah keamanan.

## <a name="author"></a>Penulis

[Auth0](https://auth0.com)

## <a name="license"></a>Lisensi

Proyek ini dilisensikan di bawah lisensi MIT. Lihat file [LICENSE](LICENSE) untuk info selengkapnya.
