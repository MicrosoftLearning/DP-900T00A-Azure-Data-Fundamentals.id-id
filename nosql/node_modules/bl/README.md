---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: id-ID
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051386"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Status Build](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Pengumpul, pembaca, dan streamer daftar Buffer Node.js.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** adalah objek penyimpanan untuk kumpulan Buffer Node, mengekspos kumpulan Buffer Node dengan API Buffer utama yang dapat dibaca. Selain itu, bl berfungsi sebagai aliran dupleks sehingga Anda dapat mengumpulkan buffer dari aliran yang memancarkannya dan memancarkan buffer ke aliran yang menggunakannya!

Buffer asli tetap utuh dan penyalinan hanya dilakukan jika diperlukan. Setiap pembacaan yang memerlukan penggunaan buffer asli tunggal hanya akan mengembalikan sebagian buffer tersebut (yang mereferensikan memori yang sama dengan buffer asli). Pembacaan yang mencakup buffer melakukan perangkaian sesuai kebutuhan dan mengembalikan hasilnya secara transparan.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Berikan panggilan balik di konstruktor dan gunakan seperti **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Perhatikan bahwa saat Anda menggunakan metode *panggilan balik* seperti ini, parameter `data` yang dihasilkan adalah perangkaian dari semua objek `Buffer` dalam daftar. Jika Anda ingin menghindari biaya dari perangkaian ini (dalam kasus kesadaran performa yang ekstrim), maka hindari metode *panggilan balik* dan cukup dengarkan `'end'` saja, seperti Aliran standar.

Atau untuk mengambil URL menggunakan [hyperquest](https://github.com/substack/hyperquest) (akan berfungsi dengan [permintaan](http://github.com/mikeal/request) dan bahkan http Node biasa juga!):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

Atau, gunakan sebagai aliran yang dapat dibaca untuk menyusun kembali daftar Buffer ke sumber output:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ]) baru
Tidak ada argumen yang _diperlukan_ untuk konstruktor, tetapi Anda dapat menginisialisasi daftar dengan meneruskan objek `Buffer` tunggal atau array objek `Buffer`.

`new` tidak sepenuhnya diperlukan, jika Anda tidak membuat objek baru, hal ini akan dilakukan secara otomatis untuk Anda sehingga Anda dapat membuat instans baru hanya dengan:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Tentukan apakah objek yang diteruskan adalah `BufferList`. Objek akan menghasilkan `true` jika objek yang diteruskan adalah instans dari `BufferList` **atau** `BufferListStream` dan `false`.

N.B. hal ini tidak akan menghasilkan `true` untuk instans `BufferList` atau `BufferListStream` yang dibuat oleh versi pustaka ini sebelum metode statik ini ditambahkan.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Dapatkan panjang daftar dalam byte. Hal ini merupakan jumlah panjang semua buffer yang terdapat dalam daftar, dikurangi offset awal untuk buffer yang setengah digunakan di awal. Harus secara akurat mewakili jumlah byte yang dapat dibaca dari daftar.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` menambahkan buffer atau BufferList tambahan ke daftar internal. `this` dikembalikan sehingga dapat dirangkai.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` akan mengembalikan byte pada indeks yang ditentukan.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` akan mengembalikan byte pada indeks yang ditentukan.
`indexOf()` metode mengembalikan indeks pertama tempat elemen tertentu dapat ditemukan di BufferList, atau -1 jika tidak ada.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` mengembalikan objek `Buffer` baru yang berisi byte dalam rentang yang ditentukan. Baik `start` dan `end` bersifat opsional dan masing-masing akan default ke awal dan akhir daftar.

Jika rentang yang diminta mencakup buffer internal tunggal maka sebagian buffer tersebut akan dikembalikan yang berbagi rentang memori asli dari Buffer tersebut. Jika rentang mencakup beberapa buffer maka operasi penyalinan kemungkinan akan terjadi untuk memberi Anda Buffer yang seragam.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` mengembalikan objek `BufferList` baru yang berisi byte dalam rentang yang ditentukan. Baik `start` dan `end` bersifat opsional dan masing-masing akan default ke awal dan akhir daftar.

Tidak ada penyalinan yang akan dilakukan. Semua buffer di hasil berbagi memori dengan daftar asli.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` menyalin konten daftar di buffer `dest`, mulai dari `destStart` dan berisi byte dalam rentang yang ditentukan dengan `srcStart` hingga `srcEnd`. `destStart`, `start` dan `end` adalah opsional dan akan menjadi default di awal buffer `dest`, serta awal dan akhir dari masing-masing daftar.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` melakukan **penyalinan dangkal** daftar. Buffer internal tetap sama, jadi jika Anda mengubah Buffer yang mendasari, perubahan tersebut akan terlihat baik pada yang Buffer asli dan duplikat. Metode ini diperlukan jika Anda ingin memanggil `consume()` atau `pipe()` dan tetap menyimpan daftar asli.Contoh:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` akan mengubah byte *dari awal daftar*. Jumlah byte yang digunakan tidak perlu disejajarkan dengan ukuran Buffer internal&mdash;offset awal akan dihitung dengan sesuai untuk memberikan tampilan data yang konsisten kepada Anda.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` akan menghasilkan representasi string dari buffer. Argumen `start` dan `end` opsional diteruskan ke `slice()`, sedangkan `encoding` diteruskan ke `toString()` dari Buffer yang dihasilkan. Lihat dokumentasi [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) untuk informasi selengkapnya.

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Semua metode pembacaan byte standar dari antarmuka `Buffer` diterapkan dan akan beroperasi di seluruh batas Buffer internal secara transparan.

Lihat dokumentasi <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> untuk mengetahui cara kerjanya.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ]) baru
**BufferListStream** adalah **[Aliran Dupleks](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** Node, sehingga dapat dibaca dan ditulis seperti aliran Node standar. Anda juga dapat `pipe()` ke dan dari instans **BufferListStream**.

Konstruktor mengambil panggilan balik opsional, jika diberikan, panggilan balik akan dipanggil dengan argumen kesalahan diikuti dengan referensi ke instans **bl**, ketika `bl.end()` dipanggil (yaitu dari aliran pipa). Hal ini merupakan metode yang mudah untuk mengumpulkan seluruh konten aliran, terutama jika aliran *berukuran kecil*, seperti aliran jaringan.

Biasanya, tidak ada argumen yang diperlukan untuk konstruktor, tetapi Anda dapat menginisialisasi daftar dengan meneruskan objek `Buffer` tunggal atau array objek `Buffer`.

`new` tidak sepenuhnya diperlukan, jika Anda tidak membuat objek baru, hal ini akan dilakukan secara otomatis untuk Anda sehingga Anda dapat membuat instans baru hanya dengan:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. Untuk alasan kompatibilitas mundur, `BufferListStream` merupakan ekspor **default** saat Anda `require('bl')`:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Kontributor

**bl** dihadirkan oleh peretas berikut:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Lisensi &amp; hak cipta

Hak Cipta (c) 2013-2019 kontributor bl (tercantum di atas).

bl dilisensikan di bawah lisensi MIT. Semua hak yang tidak secara eksplisit diberikan dalam lisensi MIT dilindungi undang-undang. Lihat file LICENSE.md yang disertakan untuk detail selengkapnya.
